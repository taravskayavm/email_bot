# Email Bot — Конфигурация через `.env`

## Dev checks
```bash
pip install pre-commit
pre-commit install
pre-commit run -a
```

Этот проект настраивается через локальный файл `.env` (не коммитится в репозиторий).
Все переменные читаются через `os.getenv`, поэтому **код править не нужно** — достаточно отредактировать `.env`.

## Запуск (legacy, python-telegram-bot)

```bash
pip install -r requirements.txt
# Рекомендуется pin: python-telegram-bot==13.15
python email_bot.py
```

## Парсинг сайтов в боте

Одна страница:

```text
/url https://example.com/page
```

Глубокий обход (несколько страниц):

```text
/crawl https://example.com
/crawl https://example.com --max-pages 80 --max-depth 3
/crawl https://example.com --prefix /staff,/contacts
```

## Конфигурация через .env
Подробности переменных окружения см. в файле `.env.example`.

## Шаблоны писем

Для каждого направления рассылки используется HTML-шаблон, расположенный в папке `templates/`.

- В **рабочей среде** у вас должны быть реальные файлы:
  ```
  templates/medicine.html
  templates/sport.html
  templates/tourism.html
  templates/psychology.html
  templates/geography.html
  templates/bioinformatics.html
  ```

- Эти файлы содержат тексты рассылок и подписи, поэтому они добавлены в `.gitignore` и **не хранятся в публичном репозитории**.

- В репозитории оставлены только примеры в `templates/examples/`:
  ```
  templates/examples/medicine.html
  templates/examples/sport.html
  templates/examples/tourism.html
  ```
  Они показывают структуру и использование плейсхолдеров:
  - `{{BODY}}` — основной текст письма
  - `{{SIGNATURE}}` — подпись (подставляется автоматически в зависимости от направления)

Таким образом, для работы бота:
1. Скопируйте свои реальные файлы писем в `templates/`.
2. Убедитесь, что их содержимое соответствует формату (содержит `{{SIGNATURE}}` или позволяет вставку подписи).
3. Репозиторий будет содержать только примеры, ваши тексты не попадут на GitHub.

## Где хранить `.env`
- Создайте файл `.env` в корне проекта (рядом с пакетом `emailbot/`).
- Проверьте, что `.env` игнорируется Git (см. `.gitignore`).
- Никогда не публикуйте `.env` в публичных репозиториях.

## Обязательные переменные
```bash
# Почта
EMAIL_ADDRESS=your_name@mail.ru                 # Ваш реальный адрес на mail.ru
EMAIL_PASSWORD=app_password_from_mailru         # Пароль приложения (не обычный)

# Telegram
TELEGRAM_BOT_TOKEN= <REDACTED># Токен @BotFather
```

**Как получить пароль приложения Mail.ru**: Почта → Настройки → Безопасность → Пароли для внешних приложений → создать для «Почта/SMTP/IMAP».

## Почтовые серверы (IMAP/SMTP)
```bash
# IMAP (для чтения «Отправленных», проверки истории и т.п.)
IMAP_HOST=imap.mail.ru
IMAP_PORT=993

# SMTP (отправка)
SMTP_HOST=smtp.mail.ru
SMTP_PORT=465          # 465 — SSL, 587 — STARTTLS
SMTP_SSL=1             # 1 = использовать SMTP_SSL(465); 0 = SMTP+STARTTLS(587)
SMTP_TIMEOUT=45        # Таймаут подключения/операций, сек
```

> Рекомендация: для Mail.ru обычно стабильнее `SMTP_SSL=1` и `SMTP_PORT=465`.

## Встроенные опции бота
```bash
# Лого в письмах (если шаблон его поддерживает)
INLINE_LOGO=1          # 1 = встраивать логотип, 0 = не встраивать
```

## Ручная рассылка — правило 180 дней
Бот может автоматически **не отправлять** письма адресатам, которым уже писали в последние N дней.
```bash
MANUAL_ENFORCE_180=1   # 1 = включить правило; 0 = выключить
MANUAL_DAYS=180        # Срок давности в днях
MANUAL_ALLOW_OVERRIDE=1# 1 = показать кнопку «Отправить всем (игнорировать 180 дней)»
```
Поведение:
- При вводе вручную списка адресов бот показывает **только счётчики**, без раскрытия адресов:
  - «К отправке (предварительно): X»
  - «Отфильтровано по правилу N дней: Y» (если есть)
- После выбора направления:
  - по умолчанию отправляет **только разрешённым** (строгое правило);
  - при включённом `MANUAL_ALLOW_OVERRIDE=1` можно нажать «Отправить всем».

## Блок-лист адресов
Базовый список служебных адресов (например, `no-reply`, `postmaster`) зашит в коде и отбрасывается всегда.
Расширить блок-лист можно одним из способов:

1) **Через ENV** (одноразовые, простые случаи):
```bash
FILTER_SUPPORT=0                   # 1 = дополнительно блокировать support@
FILTER_BLOCKLIST=help@x.com,foo@bar.io
```

2) **Отдельным файлом** (рекомендуется для постоянного ведения):
- Создайте `blocked_emails.txt` и внесите по одному адресу на строку.
- Файл не коммитьте в публичный репозиторий.
- В коде уже есть поддержка чтения/дедупликации (см. `emailbot/messaging.py`: функции `get_blocked_emails`, `dedupe_blocked_file` и т.д.).

### Включение SQLite-хранилища (опционально)
Для хранения блок-листа и аудита в SQLite:
```powershell
$env:EMAILBOT_STORAGE="sqlite"
$env:EMAILBOT_SQLITE_PATH="D:\email_bot\var\emailbot.db"
```
База создаётся автоматически при первом запуске.

## Отправленные (IMAP APPEND)
После успешной SMTP-отправки бот пытается положить письмо в папку «Отправленные» (через IMAP APPEND).
Папка определяется автоматически (`detect_sent_folder`) и кешируется в `imap_sent_folder.txt`.
Если сервер отдаёт локализованные имена (например, «Отправленные»), используется правильная кодировка IMAP (modified UTF-7).

## Режимы SMTP и устойчивость
Дополнительно доступны настройки для улучшения устойчивости:
```bash
SMTP_MODE=auto            # auto|ssl|starttls (если включено — бот может сам переключаться)
SMTP_CONNECT_RETRIES=3    # Повторы подключения при сбое
SMTP_CONNECT_BACKOFF=2    # Базовая задержка (сек), экспоненциально 2^n
```

## Диагностика
- Таймауты/разрывы: увеличьте `SMTP_TIMEOUT` и попробуйте `SMTP_SSL=1 + SMTP_PORT=465`.
- Проверка истории отправок: смотрим «Отправленные» на сервере и локальный журнал (`logs/…`, если включён).
- В логах отражаются:
  - пропуски по «дублю за сутки» (идемпотентность),
  - пропуски по блок-листу,
  - ожидания rate-limit по домену.

## FAQ
**В: Где менять поведение бота?**  
О: В `.env`. Код уже читает все ключевые переменные через `os.getenv`.

**В: Почему мои «Отправленные» не находят?**  
О: Проверьте `IMAP_HOST/PORT`, доступ, и что `imap_sent_folder.txt` содержит корректное имя. При смене сервера удалите этот файл — папка определится заново.

**В: Почему вручную отправились письма «раньше 180 дней»?**
О: Для ручной рассылки раньше правило было отключено; теперь включается `MANUAL_ENFORCE_180=1`. При `MANUAL_ALLOW_OVERRIDE=1` можно вручную разрешить отправку всем.

## Нормализация и валидация e-mail

- Локальная часть (то, что слева от `@`) допускает только **ASCII-символы**. Адреса с Unicode-локалью
  отвергаются как не совместимые с большинством SMTP-серверов и библиотек (код: `local_not_ascii`).
  Примеры отказов: `имя@пример.рф`.

- Доменная часть (справа от `@`) поддерживает Unicode и автоматически кодируется в **IDNA (Punycode)**.
  Например: `user@пример.рф` → `user@xn--e1afmkfd.xn--p1ai`.

- Дополнительно:
  - Запрещены точка в начале/конце локали и две точки подряд внутри локали.
  - Длины домена и лейблов проверяются (RFC-согласованные пределы).
  - В отчёте импорта отображаются **причины отбраковки** (см. коды в разделе `/ingest`).

## Импорт адресов (`/ingest`)

Отошлите команду `/ingest` и построчно список адресов/строк — бот извлечёт валидные e-mail, покажет статистику и примеры.
Теперь отчёт включает:

- `Годных адресов`, `Отброшено` и `Всего строк`;
- агрегированную таблицу причин отбраковки (например, `локальная часть не ASCII`, `некорректный домен` и т.п.).

### Парсинг URL

Отправьте в чат **сообщение со ссылкой** (например, `https://example.com/about`).
Бот сначала ответит «Приняла ссылку…», затем пришлёт сводку с количеством найденных адресов и примерами.

### Обфусцированные адреса (`[at]/[dot]/«собака/точка»`)
По умолчанию бот распознаёт такие паттерны, но стоит жёсткий анти-спам фильтр, чтобы не собирать мусор.
Если у вас **реально используются цифровые локали** (например, ID-логины), включите:

```bash
export OBFUSCATION_ALLOW_NUMERIC_LOCAL=1
```

Это позволит извлекать и обфусцированные адреса вида `123456 [at] uni [dot] edu`.

### Загрузка файлов

Можно отправлять файлы: **PDF, DOCX, XLSX, CSV, ZIP** (с этими файлами внутри).
Бот:
1) скачает файл;
2) извлечёт текст и e-mail-адреса;
3) покажет отчёт, включая причины отбраковки (например, «локальная часть не ASCII»).

> Зависимости для некоторых форматов необязательны:
> - `.xlsx` → `openpyxl`
> - `.docx` → `python-docx`
> - `.pdf` → `pdfminer.six`
>
> Если пакета нет, бот не упадёт — он сообщит, какую зависимость установить.

### OCR для сканированных PDF

Если предпросмотр показывает много страниц со счётчиком `needs_ocr`, включите OCR:

```bash
ENABLE_OCR=1    # активирует распознавание текста в сканах
OCR_PAGE_LIMIT=10  # максимум страниц одного документа для OCR
OCR_TIME_LIMIT=30  # таймаут распознавания, секунд
```

OCR делает обработку медленнее, поэтому по умолчанию флаг выключен. Пределы по
страницам и времени помогают избежать «зависших» документов — при желании их
можно ослабить, но имейте в виду увеличение нагрузки.

#### Адаптивный таймаут PDF
По умолчанию включён адаптивный таймаут обработки PDF:
```
T = clamp(PDF_TIMEOUT_BASE + PDF_TIMEOUT_PER_MB * size_mb, PDF_TIMEOUT_MIN, PDF_TIMEOUT_MAX)
```
Переменные окружения (значения по умолчанию указаны справа):
```ini
PDF_ADAPTIVE_TIMEOUT=1
PDF_TIMEOUT_BASE=15
PDF_TIMEOUT_PER_MB=0.6
PDF_TIMEOUT_MIN=15
PDF_TIMEOUT_MAX=90
```
Чтобы вернуться к фиксированному таймауту, отключите адаптивный режим:
```ini
PDF_ADAPTIVE_TIMEOUT=0
PDF_EXTRACT_TIMEOUT=25
```

## Windows (Anaconda PowerShell) — быстрый старт

1. Откройте **Anaconda PowerShell Prompt**.
2. Перейдите в каталог проекта:
   ```powershell
   cd /d D:\email_bot
   ```
3. Активируйте окружение:
   ```powershell
   conda activate emailbot
   ```
4. Установите зависимости:
   ```powershell
   pip install -r requirements.txt
   ```
5. Очистите кэши и сборочные артефакты (PowerShell):
   ```powershell
   .\scripts\cleanup.ps1
   ```
   В **cmd.exe** эквивалентная команда:
   ```cmd
   rd /s /q __pycache__
   ```
6. Запустите тесты:
   ```powershell
   pytest -q
   ```
